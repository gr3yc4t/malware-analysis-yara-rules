import "pe"

//Detect capabilities needed for the DLL injection
// ProcessA -> OpenProcess(); -> ProcessB
// ProcessA -> VirtualAlloc(); -> ProcessB
// ProcessA -> WriteProcessMemory(); -> ProcessB
// LoadLibraryExA()
// Get..Offset()
// CreateRemoteThread();
// NtCreateThreadEx();
// RtlCreateUserThread;


rule dll_injection_thread : feature dll injection windows{
meta:
	description = "Injection using kernel32.dll:VirtualAllocEx"

strings:
	$load_01 = "LoadLibraryA"
	$remote_01 = "NtCreateThreadEx"

condition:
	// MZ at the beginning of file
        uint16(0) == 0x5a4d and

	// Access other process
	//(
	//	pe.imports("kernel32.dll","OpenProcess")
	//) and

	// Allocate memory in remote process
	(
		pe.imports("kernel32.dll","VirtualAllocEx")
	)and

	// Write code section to the remote process
	(
		pe.imports("kernel32.dll","WriteProcessMemory") or
		pe.imports("kernel32.dll","LoadLibraryExA") or
		pe.imports("kernel32.dll","LoadLibraryExW") or
		(
			pe.imports("kernel32.dll","GetProcAddress") and
			( pe.imports("kernel32.dll","GetModuleHandleA") or pe.imports("kernel32.dll","GetModuleHandleA") ) and
			$load_01
		)
	) and

	//Execute
	(
		pe.imports("kernel32.dll","CreateRemoteThread") or
		pe.imports("ntdll.dll","NtCreateThreadEx") or
		(
			pe.imports("kernel32.dll","GetProcAddress") and
			( pe.imports("kernel32.dll","GetModuleHandleA") or pe.imports("kernel32.dll","GetModuleHandleA") ) and
			$remote_01
		)
	)

}



rule dll_injection_hook : feature dll injection windows
{
meta:
	description = "Injection using User32.dll:VirtualAllocEx"
	author = "gr3yc4t"
	version = "0.1"
strings:
	$setHook = "SetWindowsHook"
	$callNext = "CallNextHookEx"
condition:
	(
		pe.imports("user32.dll","SetWindowsHookExA") or
		pe.imports("user32.dll","SetWindowsHookExW")
	)
	or
	(
		$setHook or $callNext
	)
}




rule inject_thread {
    meta:
        author = "x0r"
        description = "Code injection with CreateRemoteThread in a remote process"
		version = "0.1"
    strings:
        $c1 = "OpenProcess"
        $c2 = "VirtualAllocEx"
        $c3 = "NtWriteVirtualMemory"
        $c4 = "WriteProcessMemory"
        $c5 = "CreateRemoteThread"
        $c6 = "CreateThread"
        $c7 = "OpenProcess"
    condition:
        $c1 and $c2 and ( $c3 or $c4 ) and ( $c5 or $c6 or $c7 )
}


rule find_victim_process {
	meta:
		author = "gr3yc4t"
		description = "Calls used to cycle over existing process"
	strings:
		//Classical Loop
			$snapshotCall = "CreateToolhelp32Snapshot"
			$process32First = "Process32First"
			$process32Next = "Process32Next"
		//Alternative Method
			$queryInfo = "QuerySystemInformation"
	condition:
		(
			$snapshotCall and $process32First and $process32Next
		)
		or
			$queryInfo
		or
		(
			pe.imports("ntdll.dll", "NtQuerySystemInformation") or
			pe.imports("ntdll.dll", "ZwQuerySystemInformation")
		)
}

rule find_victim_thread {
	meta:
		author = "gr3yc4t"
		description = "Calls used to cycle over existing thread"
	strings:
		//Classical Loop
			$snapshotCall = "CreateToolhelp32Snapshot"
			$process32First = "Thread32First"
			$process32Next = "Thread32Next"
		//Alternative Method
			$queryInfo = "QuerySystemInformation"

	condition:
		(
			$snapshotCall and $process32First and $process32Next
		)
		or
			$queryInfo
		or
		(
			pe.imports("ntdll.dll", "NtQuerySystemInformation") or
			pe.imports("ntdll.dll", "ZwQuerySystemInformation")
		)
}

rule thread_execution_hijacking {
		meta: 
			author = "gr3yc4t"
			description = "Calls used to perform a Thread execution hijacking"
			version = "0.1"
		strings:
			$openThread = "OpenThread"
			$suspendThread = "SuspendThread"
			$resumeThread = "ResumeThread"


			$virtualAlloc = "VirtualAllocEx"
			$writeProcessMemory = "WriteProcessMemory"
			$getThreadContext = "GetThreadContext"
			$setThreadContext = "SetThreadContext"
		condition:
			($openThread or $suspendThread or $resumeThread)
			and
			($virtualAlloc and $writeProcessMemory)
			and 
			($getThreadContext or $setThreadContext)
}



rule process_hollowing_injection {
	meta: 
		author = "gr3yc4t"
		description = "Code injection via Process Hollowing"
		version = "0.1"
	strings:
		//The operation "push CREATE_SUSPENDED" of "CreateProcess"
		$create_suspened_parameter = { 6A 04 }	

		$step1_string = "CreateProcess"
		$step2_opt_string = "ZwUnmapViewOfSection"
		$step3_string = "VirtualAlloc"
		$step4_string = "WriteProcessMemory"
		$step5_opt_string = "ResumeThread"
		$step6_opt_string = "SetThreadContext"

	condition:
		$step1_string and $create_suspened_parameter 
		 and $step3_string and $step4_string 
		 and ($step2_opt_string or $step5_opt_string or $step6_opt_string)
}


rule dynamically_loaded_api {
	meta: 
		author = "gr3yc4t"
		description = "Check if the malware dynamically load imports"
	strings: 
		$getProcAddress = "GetProcAddress"

		//First Type, import function of an already loaded module
		//Malware can import only one function per DLL and solve functions
		//manually with "GetProcAddress"
		$getModuleHandle = "GetModuleHandle"

		//Second Type, used to reconstruct the Import Address Table
		$loadLibrary = "LoadLibrary"
	condition:
		$getProcAddress and ($getModuleHandle or $loadLibrary)
}


rule possible_apc_injection {
	meta:
		author ="gr3yc4t"
		description = "Detect APC injection"
	strings:
		$queueCall = "QueueUserAPC"
		$ntQueue = "NtQueueApcThread"

		//Kernel level
		$initializeAPC = "KeInitializeApc"
		$insertQueue = "KeInsertQueueApc"
	condition:
		(
			//User level
			$queueCall or $ntQueue
		)
		or
		(
			//Kernel level
			$initializeAPC and $insertQueue
		)
		or
		(
			pe.imports("kernel32.dll","QueueUserAPC") or
			pe.imports("ntdll.lib", "NtQueueApcThread") or

		)
}